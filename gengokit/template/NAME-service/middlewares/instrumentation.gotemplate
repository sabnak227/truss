// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

package middlewares

// This file contains middlewares wrapping around endpoints from services,

import (
	"context"
	"fmt"
	"time"

	"github.com/go-kit/kit/metrics"
	pb "{{.PBImportPath -}}"
)


func InstrumentationMiddleware(requestCount metrics.Counter, errCount metrics.Counter, requestLatency metrics.Histogram) {{.Service.Name}}ServiceMiddleware {
	return func(next pb.{{.Service.Name}}Server) pb.{{.Service.Name}}Server {
		return instrumentingMiddleware{
			requestCount:   requestCount,
            errCount:       errCount,
            requestLatency: requestLatency,
            next:           next,
		}
	}
}

// instrumentationMiddleware implements pb.{{.Service.Name}}Server in order to
// easily trace requests throughout a distributed system.
type instrumentingMiddleware struct {
	requestCount   metrics.Counter
	errCount       metrics.Counter
	requestLatency metrics.Histogram
	next           pb.{{.Service.Name}}Server
}

{{with $te := . }}
	{{range $i := $te.Service.Methods}}
		// {{$i.Name}} implements pb.{{$te.Service.Name}}Service in order to
		// provide distributed tracing visibility.
		func (im instrumentingMiddleware) {{$i.Name}}(ctx context.Context, req *pb.{{GoName $i.RequestType.Name}}) (res *pb.{{GoName $i.ResponseType.Name}}, err error){
            begin := time.Now()
			res, err = im.next.{{$i.Name}}(ctx, req)

			lvs := []string{"method", "{{ToLower $i.Name}}", "error", fmt.Sprint(err != nil)}
            im.requestCount.With(lvs...).Add(1)
            im.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds())
            if(err != nil) {
                im.errCount.With(lvs...).Add(1)
            }
			return
		}
	{{end}}
{{- end}}

