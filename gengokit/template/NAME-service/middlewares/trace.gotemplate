// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

package middlewares

// This file contains middlewares wrapping around endpoints from services,

import (
	"context"
	"fmt"

	zipkin "github.com/openzipkin/zipkin-go"
	"github.com/openzipkin/zipkin-go/model"
	pb "{{.PBImportPath -}}"
)

func TracingMiddleware(t *zipkin.Tracer) {{.Service.Name}}ServiceMiddleware {
	return func(next pb.{{.Service.Name}}Server) pb.{{.Service.Name}}Server {
		return tracingMiddleware{
			tracer: t,
			next:   next,
		}
	}
}

// tracingMiddleware implements pb.{{.Service.Name}}Server in order to
// easily trace requests throughout a distributed system.
type tracingMiddleware struct {
	tracer *zipkin.Tracer
	next   pb.{{.Service.Name}}Server
}


{{with $te := . }}
	{{range $i := $te.Service.Methods}}
		// {{$i.Name}} implements pb.{{$te.Service.Name}}Service in order to
		// provide distributed tracing visibility.
		func (tm tracingMiddleware) {{$i.Name}}(ctx context.Context, req *pb.{{GoName $i.RequestType.Name}}) (res *pb.{{GoName $i.ResponseType.Name}}, err error){
			serverSpan, tracedCtx := spanCreator(ctx, tm.tracer, "{{$i.Name}}")
			defer serverSpan.Finish()
			defer spanRecoverer(tracedCtx, serverSpan, "{{$i.Name}}")

			res, err = tm.next.{{$i.Name}}(tracedCtx, req)
			spanLogger(tracedCtx, serverSpan, "{{$i.Name}}", err)
			return
		}
	{{end}}
{{- end}}

// spanCreator creates a new trace span throughout the distributed system.
func spanCreator(ctx context.Context, t *zipkin.Tracer, methodName string) (zipkin.Span, context.Context) {
	var sc model.SpanContext
	parentSpan := zipkin.SpanFromContext(ctx);
	if parentSpan != nil {
		sc = parentSpan.Context()
	}
	sp := t.StartSpan(methodName, zipkin.Parent(sc))

	ctx = zipkin.NewContext(ctx, sp)
	return sp, ctx
}

// spanLogger logs some information into the span created
func spanLogger(ctx context.Context, span zipkin.Span, methodName string, err error) {
	span.Tag("MethodName", methodName)
	if err != nil {
		span.Tag("Error", err.Error())
	}
}

// spanRecoverer tells us information when there is a panic occurs
func spanRecoverer(ctx context.Context, span zipkin.Span, methodName string) {
	if r := recover(); r != nil {
		// we've had a panic, record via opentracing
		span.Tag("MethodName", methodName)
		span.Tag("Panic", fmt.Sprintf("%v", r))
	}
}
