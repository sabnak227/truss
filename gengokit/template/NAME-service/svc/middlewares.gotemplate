// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

package svc

// This file contains middlewares wrapping around endpoints from services,

import (
	"context"
	"fmt"
	"time"

	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/metrics"
	zipkin "github.com/openzipkin/zipkin-go"
	"github.com/openzipkin/zipkin-go/model"
	pb "github.com/sabnak227/follow-service/pb"
)

func InstrumentingMiddleware(duration metrics.Histogram) LabeledMiddleware {
	return func(name string, in endpoint.Endpoint) endpoint.Endpoint {
		return func(ctx context.Context, req interface{}) (rsp interface{}, err error) {
			defer func(begin time.Time) {
				duration.Observe(time.Since(begin).Seconds())
			}(time.Now())
			return in(ctx, req)
		}
	}
}

func LoggingMiddleware(logger log.Logger) LabeledMiddleware {
	return func(name string, in endpoint.Endpoint) endpoint.Endpoint {
		return func(ctx context.Context, req interface{}) (rsp interface{}, err error) {
			defer func(begin time.Time) {
				logger.Log("endpoint", name, "input", req, "output", rsp, "err", err, "took", time.Since(begin))
			}(time.Now())
			return in(ctx, req)
		}
	}
}


// Middleware describes a service (as opposed to endpoint) middleware.
type FollowServiceMiddleware func(pb.FollowServer) pb.FollowServer

func TracingMiddleware(t *zipkin.Tracer) FollowServiceMiddleware {
	return func(next pb.FollowServer) pb.FollowServer {
		return tracingMiddleware{
			tracer: t,
			next:   next,
		}
	}
}

// tracingMiddleware implements pb.FollowServer in order to
// easily trace requests throughout a distributed system.
type tracingMiddleware struct {
	tracer *zipkin.Tracer
	next   pb.FollowServer
}


{{with $te := . }}
	{{range $i := $te.Service.Methods}}
		// {{$i.Name}} implements pb.{{$te.Service.Name}}Service in order to
		// provide distributed tracing visibility.
		func (tm tracingMiddleware) {{$i.Name}}(ctx context.Context, req *pb.{{GoName $i.RequestType.Name}}) (res *pb.{{GoName $i.ResponseType.Name}}, err error){
			serverSpan, tracedCtx := spanCreator(ctx, tm.tracer, "{{$i.Name}}")
			defer serverSpan.Finish()
			defer spanRecoverer(tracedCtx, serverSpan, "{{$i.Name}}")

			res, err = tm.next.{{$i.Name}}(tracedCtx, req)
			spanLogger(tracedCtx, serverSpan, "{{$i.Name}}", err)
			return
		}
	{{end}}
{{- end}}

// spanCreator creates a new trace span throughout the distributed system.
func spanCreator(ctx context.Context, t *zipkin.Tracer, methodName string) (zipkin.Span, context.Context) {
	var sc model.SpanContext
	parentSpan := zipkin.SpanFromContext(ctx);
	if parentSpan != nil {
		sc = parentSpan.Context()
	}
	sp := t.StartSpan(methodName, zipkin.Parent(sc))

	ctx = zipkin.NewContext(ctx, sp)
	return sp, ctx
}

// spanLogger logs some information into the span created
func spanLogger(ctx context.Context, span zipkin.Span, methodName string, err error) {
	span.Tag("MethodName", methodName)
	if err != nil {
		span.Tag("Error", err.Error())
	}
}

// spanRecoverer tells us information when there is a panic occurs
func spanRecoverer(ctx context.Context, span zipkin.Span, methodName string) {
	if r := recover(); r != nil {
		// we've had a panic, record via opentracing
		span.Tag("MethodName", methodName)
		span.Tag("Panic", fmt.Sprintf("%v", r))
	}
}
